10.12.2019

ARM

Процессоры архитектуры ARM относятся к RISC-процессорам. Что предполагает относительно большое количество регистров общего назначения, унифицированный формат машинных инструкций, одинаковую длину инструкций, относительно простые действия, выполняемые инструкциями. Это позволяет быстро декодировать и выполнять инструкции, но усложняет процесс разработки на языке ассемблера.


Регистры общего назначения.
16 32-х разрядных регистров R0-R15.
Некоторые из них имеют специальное назначение:
R12	FP	(аналог ebp)		база кадра стека
R13	SP	(аналог esp)		вершина стека
R14	LR						адрес возврата
R15	PC	(аналог eip)		указатель инструкций


Инструкции в основном наборе команд имеют длину в 4 байта. Это накладывает ограничения на доступные инструкции и способы адресации. Например, нельзя в инструкции указать непосредственное 4-х байтовое значение, например, абсолютный адрес.

Аргументами для вычислений могут быть только значения в регистрах либо небольшие (8 бит) непосредственные значения. Значения в памяти можно обрабатывать, только предварительно загрузив их в регистры.

Команды обработки данных
<команда>  <регистр назначения>, <1-й операнд>, <2-й операнд>
add
sub
mul
and
eor
orr

Команда загрузки значения в регистр (из другого регистра или непосредственного значения)
mov Rd, <операнд>
В качестве операнда может выступать регистр или непосредственное значение.

Значение 2-го операнда, заданного регистром, может быть предварительно сдвинуто
add  Rd, Rn, Rm, shift k          ; Rd := Rn + (Rm shift k),
где shift одна из команд сдвига:
lsl – логический сдвиг влево
asl – арифметический сдвиг влево
lsr – логический сдвиг вправо
asr – арифметический сдвиг вправо
ror – вращение вправо
rrx – однократное вращение вправо с флагом переноса.

Значение 2-го операнда, заданного непосредственным 8-ми битовым значением, может быть циклически сдвинуто вправо на 2*k (в инструкции хранится 4-х битовое k).
mov Rd, imm8 ROR 2*k 		; Rd := imm8 ror 2 * k
Синтаксис языка ассемблера позволяет указывать значение, которое необходимо загрузить в регистр, а ассемблер сам высчитает каким сдвигом его можно получить:
mov Rd, #0x2200
add Rd, Rn, #0x440000


Команды загрузки из памяти в регистр
ldr Rd, <адрес>		загрузка 4-х байт в регистр
ldrh Rd, <адрес>	загрузка 2-х байт в регистр с расширением нулями
ldrb Rd, <адрес>	загрузка байта в регистр с расширением нулями
ldrsh Rd, <адрес>	загрузка 2-х байт в регистр со знаковы расширением
ldrsb Rd, <адрес>	загрузка байта в регистр со знаковы расширением

Сохранение регистра в память
str Rd, <адрес>		сохранение 4-х байт в память
strh Rd, <адрес>	сохранение младших 2-х байт в память
strb Rd, <адрес>	сохранение младшего байта в память


Адрес может быть в одном из режимов адресации:
ldr  Rd, [Rn,#-смещение12]    ; Rd:=[Rn-смещение12]
ldr  Rd, [Rn,#+смещение12]!   ; адр:=Rn+смещение12, Rd:=[адр], Rn:=адр
ldr  Rd, [Rn],#-смещение12    ; Rd:=[Rn], Rn:=[Rn-смещение12]
ldr  Rd, [Rn,-Rm,LSL k]       ; Rd:=[Rn+((-Rm) LSL k)]
str  Rd, [Rn,Rm,LSR k]        ; [Rn+(Rm LSR k)]:=Rd
str  Rd, [Rn,-Rm,ROR k]!      ; адр:=Rn+((-Rm) ROR k), [адр]:=Rd, Rn:=адр
str  Rd, [Rn],Rm,ASR k        ; [Rn]:=Rd, Rn:=Rn+(Rm ASR k)
! - означает обновление регистра Rn

Регистр PC (например, при использовании его в качестве базового регистра при адресации) хранит адрес инструкции по смещению +8 от исполняемой.

Сохранение нескольких регистров в памяти по адресу, указанном в регистре Rd.
stm<режим адресации>  Rd{!}, <список регистров>
где режим адресации определяет изменение адреса при сохранении
ia	увеличение после сохранения
ib	увеличение перед сохранением
da	уменьшение после сохранения
db	уменьшение перед сохранением
stmdb sp!, {r0, r1}		; [sp-4]=r1, [sp-8]=r0, sp=sp-8
Порядок следования регистров в списке не важен. Регистры помещаются с младших номеров по порядку с младшего адреса


Загрузка нескольких регистров из памяти по адресу, указанном в регистре Rd.
ldm<режим адресации>  Rd{!}, <список регистров>
где режим адресации определяет изменение адреса при сохранении
ia	увеличение после сохранения
ib	увеличение перед сохранением
da	уменьшение после сохранения
db	уменьшение перед сохранением
ldmia sp!, {r0, r1}		; r0=[sp], r1=[sp+4], sp=sp+8
Порядок следования регистров в списке не важен. Регистры извлекаются с младших номеров по порядку с младшего адреса.

Команды stm/ldm позволяют сохранять/загружать регистры относительно любого регистра. Если предполагается работа со стеком, вместо мнемоник ia, ib, da, db более естественным может быть использование других мнемоник (которые в итоге транслируются в одну этих четырёх):
fd	стек растёт вниз, вершина указывает на (последнюю) занятую ячейку
ed	стек растёт вниз, вершина указывает на (первую) свободную ячейку
fa	стек растёт вверх, вершина указывает на (последнюю) занятую ячейку
ea	стек растёт вверх, вершина указывает на (первую) свободную ячейку
По сути каждая мнемоника задаёт одну из 4 моделей работы со стеком. Указывая мнемонику в инструкции мы сообщаем компилятору с какой моделью стека работаем, а он уже самостоятельно выбирает нужный режим адресации для поддержания этой модели.
Стандартная модель работы со стеком - fd.
Поэтому в коде мы можем использовать инструкции stmfd/lmdfd, которые компилятор преобразует в stmdb/ldmia.



Передача управления
b imm24		передача управления по смещению
bl imm24	передача управления по смещению с сохранением адреса возврата в регистр LR
imm24 - 24-х битовое знаковое смещение относительно регистра PC (который содержит адрес текущей инструкции + 8)
Это значение знаково расширяется до 30 бит и смещается влево на 2 бита (так как инструкции выровнены по границам 4 байт). Полученное 32-х битовое значение прибавляется к регистру PC для получения адреса назначение.
В исходном коде для инструкций указывается имя метки, на которую необходимо перейти (ассемблер высчитывает значение смещения).

bx Rd		передача управления по адресу в регистре


Команды сравнения
cmp Rn, <2-й операнд>		Rn - <2-й операнд>
cmn Rn, <2-й операнд>		Rn + <2-й операнд>
teq Rn, <2-й операнд>		Rn ^ <2-й операнд>
tst Rn, <2-й операнд>		Rn & <2-й операнд>



Каждая инструкция может быть выполнена условно в зависимоти от значения флагов. Для этого в каждой инструкции предусмотрено 4 бита кода условия. На языке ассемблера синтаксически это выражается добавлением суффикса после имени инструкции
<команда><код условия>

Коды условий
EQ	равно
NE	не равно
CS/HS	Carry Set / Unsigned higher or same		есть перенос / старше или такое же
CC/LO	Carry Clear / Unsigned lower		нет переноса / младше
MI	Minus	отрицательно
PL	Plus	положительно или 0
VS	Overflow	переполнено
VC	No overflow		не переполнено
HI	Unsigned higher		старше
LS	Unsigned lower or same		младше или такое же
GE	Signed greater than or equal	больше или равно
LT	Signed less than		меньше
GT	Signed greater than		больше
LE	Signed less than or equal		меньше или равно
AL	Always	всегда (обычно опускается)



Вызов функций.

Стандартный пролог.
stmfd sp!, {fp, lr}		@ [sp-4]=lr, [sp-8]=fp
add	fp, sp, #4			@ fp указывает на адрес возврата
sub sp, #XY

fp-8	1-ая локальная переменная
fp+4	5-ый аргумент

Стандартный эпилог.
sub	sp, fp, #4
ldmfd sp!, {fp, lr}
bx lr
вместо последних двух инструкций можно
ldmfd sp!, {fp, pc}

Аргументы передаются в нотации cdecl. Первые 4 аргумента передаются через регистры r0-r3, остальные через стек справа налево.
Значения возвращаются через регистр r0 (при необходимости r1).



Примеры

1. hello.c, hello_c.S
Файл hello_c.S получен из исходного C-файла с помощью компиляции без ассемблирования:
# gcc -S -o hello_c.S hello.c
Этот файл можно сассемблировать:
# gcc -o hello hello_c.S
Таким образом можно разбираться в архитектурных особенностях, реализовав код на Си и заставив компилятор перевести его в рабочий ассемблерный код.


2. sum
Демонстрация реализации операции:
var1 = var2 + var3


3. reg
Демонстрация некоторых особенностей работы с памятью/регистрами.
