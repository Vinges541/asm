03.09.2019

I пара

Архитектура процессоров (АЛУ, регистры, кэш-память, УУ).
Оперативная память.
Системные шины.
Порты ввода-вывода.
Проецирование аппаратных ресурсов на виртуальную память.

Система команд (RISC, CISC).
Формат машинной команды.

Исполнение инструкций происходит в соответствии с принципами программного управления (Чарльз Беббидж, Джон фон Нейман):
1) Обрабатываемая информация кодируется двоичными цифрами и разделяется на единицы. Минимальная доступная для непосредственного доступа единица информации называется байтом (обычно равна 8 бит), максимальная - машинным словом (равна разрядности процессора).
Алгоритм вычислений представляется в форме программы, состоящей из последовательности команд (записанных также в двоичной форме). Каждая команда предписывает некоторую операцию.
2) Команды хранятся в последовательности смежных ячеек памяти и выполняются в естественном порядке. При необходимости естественный порядок может быть изменен. Могут быть специальные инструкции передачи управления, либо в каждой инструкции указывается адрес следующей.
3) Команды и данные хранятся в одной памяти.

Функционирование машины заключается в повторении до останова последовательности шагов:
1) чтение команды;
2) расшифровка кода операции;
3) выборка операндов;
4) выполнение операции;
5) запись результата;
6) определение адреса следующей команды.



II пара

Адресация памяти.

В 16-разрядном реальном режиме работы процессора существует два типа адресов: (полный) логический и физический.
Логический состоит из двух частей: сегмента и смещения (эффективный адрес).
Сегментная составляющая определяет адрес начала сегмента и содержится в одном из сегментных регистров (старшие 16 бит адреса из 20).
Вторая 16-битная составляющая определяет смещение внутри сегмента. Смещение хранится в одном из регистров или может быть указано непосредственно.

Логический адрес текущей инструкции определяется парой сегментов:
cs:ip
т.е. очередная инструкция извлекается из памяти по этому адресу, после чего регистр ip увеличивается на величину инструкции.

Вершина стека:
ss:sp
т.е. инструкции push и pop работают с вершиной стека по этому адресу.
push уменьшает регистр sp на 2 и помещает по адресу ss:sp значение.
pop считывает слово по адресу ss:sp и увеличивает регистр sp на 2

При обращении к данным можно указать какой сегментный регистр использовать:
mov ds:[ax],0
mov es:[ax],0
mov ds:[0x100],0
mov es:[0x100],0
Сегментный регистр ds для адресации данных подразумевается по умолчанию, поэтому его можно не указывать. Также при обращении к данным через стековый регистр подразумевается обращение к стеку, поэтому инструкция
mov [sp],0
равносильна
mov ss:[sp],0

Логическая адресация существует только на уровне системы команд процессора. Для непосредственного обращения к данным необходим физический адрес ячейки памяти, который выставляется на шину адреса. Поэтому перед обращением процессора к памяти логический адрес преобразуется в физический:
физ. адр. = сегм. рег. << 4 + смещение

В защищённом 32-разрядном режиме появляется ещё один тип адреса: линейный. Логический адрес путем сложения адреса начала сегмента со смещением преобразуется в линейный адрес. Линейный адрес является адресом в виртуальном адресном пространстве, который механизмом страничной трансляции через каталог и таблицу страниц преобразуется в физический.


Сегментация памяти.

В реальном режиме память логически разбивается на сегменты размером 64 КБ.
Адреса сегментов, выровненные по границе 16 байт, загружаются в соответствующие сегментные регистры.
В защищённом режиме сегментные регистры содержат селектор.
2 младших бита селектора определяют запрашиваемый уровень привилегий (проверяется при загрузке селектора в сегментный регистр). Уровень привилегий селектора, загруженного в данный момент в регистр cs определяет текущий уровень привилегий, в котором работает процессор. Содержимое третьего бита указывает какую таблицу дескрипторов использовать:
0 - глобальную (Global Descriptor Table - GDT), её адрес в регистре gdtr
1 - локальную (Local Descriptor Table - LDT), её адрес в регистре ldtr
Старшие 13 бит содержат индекс дескриптора в глобальной или локальной таблице дескрипторов, т.е. может быть 8192 дескриптора в таблице.
Дескриптор - это 64-битная структура данных.
Дескрипторы могут являться дескрипторами сегмента: кода и данных. Тогда они описывают адрес начала сегмента (база), его размер, права доступа. Или являться системными дескрипторами (дескриптор LDT, состояния задачи, шлюза).

В современных операционных системах разделения на сегменты не происходит - используется плоская (flat) модель памяти. Так как аппаратно отключить сегментацию памяти на процессорах семейства IA32 невозможно, этого добиваются при помощи расширения сегментов кода, данных и стека на всё виртуальное адресное пространство. При этом разделение пространства на код, данные и стек происходит с помощью второй составляющей логического адреса - смещения внутри сегмента (которое по сути совпадает с линейным адресом, так как адрес начала сегмента нулевой).


Создание кода.

Процесс преобразования исходного кода на некотором языке программирования в исполняемый файл разбивается на два этапа: компиляция и линковка.
В процессе компиляции файл исходного кода преобразуется в объектный файл. Объектный файл можно рассматривать как контейнер для хранения кода и данных, хранящихся вместе с символьной информацией им соответствующей (имена функций и глобальных переменных). Для каждого известного символа (имени функции или глобальной переменной) хранятся адрес и размер.
Вместе с этим в объектном файле есть таблица внешних символов, которые не определены в этом файле, но к которым осуществляется обращение из функций, в этом файле содержащихся. Это могут быть имена библиотечных функций или глобальных переменных из других модулей.

На этапе линковки объектные файлы вместе с файлами библиотек (lib файлы, являющиеся архивами объектных файлов) объединяются в один исполняемый файл. Перед этим линковщик должен найти для всех внешних символов всех входных объектных файлов их определение среди известных символов входных файлов и подставить соответствующие адреса (отредактировать связи). 
Кроме этого линковщик должен назначить какой-то адрес в исполняемом файле в качестве точки входа. В качестве неё может быть функция с именем, которое линковщик по умолчанию считает точкой входа (для разных линковщиков это могут быть: _main, _start, _mainCRTStartup), либо функция указанная с помощью специального аргумента командной строки.

Объектные файлы могут линковаться с библиотеками статически либо динамические.
При статической линковке в исполняемый файл помещается скомпилированный код вызываемой библиотечной функции.
При динамической линковке вместо кода функции в исполняемый файл помещается ссылка на динамическую библиотеку, содержающую код нужной функции, в специальную таблицу импорта. В момент загрузки исполняемого файла загрузчик операционной системы загружает требуемую динамическую библиотеку. Затем динамический линковщик проставляет адреса вызываемых внешних (импортируемых) символов в таблицу импорта загружаемого исполняемого файла.


Разбор примеров в каталоге examples.

Примеры написаны на языке ассемблера для masm32.
Директивы ассемблера, встречающиеся в коде:

; указание ассемблеру инструкции какого процессора поддерживать
.686

; указание ассемблеру использовать плоскую модель памяти,
; единственную используемую в современных операционных системах
.model flat

Директивы описания секций.

.const	; сегмент доступных только для чтения данных
.data	; сегмент доступных для чтения и записи инициализированных данных
.data?	; сегмент доступных для чтения и записи неинициализированных данных
.code	; сегмент кода


1) Пример пустой программы, которая сразу же возвращает управление.

Ассемблируем командой (ключ /c указывает ассемблеру не линковать):
> ml /c hello.asm

При линковке указываем точку входа и подсистему
> link /entry:main /subsystem:console hello.obj

Получили исполняемый файл размером 1КБ.


2) В этом примере программа также сразу же завершается.
Только для этого вызывает стандартная библиотечная функция ExitProcess.

Для того чтобы использовать внешнюю функцию необходимо определить ее прототип:
ExitProcess proto stdcall :dword

Для вызова функции можно использовать директиву:
invoke ExitProcess, 0
которая, основываясь на прототипе функции, сгенерирует код вызова функции с параметрами.

После этого можем ассемблировать прежней командой:
> ml /c hello.asm

В данном примере вместо функции main определена функция mainCRTStartup. Это имя линковщик использует в качестве точки входа по умолчанию. Следовательно при линковке нет необходимости указывать ее явно. Так как в данном примере вызывается внешняя функция при линковке необходимо подключить библиотеку импорта, в которой она определена:
> link /subsystem:console hello.obj kernel32.lib


3) В данном примере определена функция main.
И при линковке мы не будем указывать её в качестве точки входа. Вместо этого слинкуем программу со стандартной библиотекой языка Си, которая вставит свой код в качестве точки входа. Обычно это и происходит, когда мы собираем программу на языке Си. Этот код инициализирует библиотеку, а также вызывает функцию main с правильными аргументами.

Мы можем слинковать с динамической библиотекой msvcrt.lib:
> link hello.obj kernel32.lib msvcrt.lib

или со статической библиотекой libcmt.lib:
> link hello.obj kernel32.lib libcmt.lib

В первом случае получим исполняемый файл размером 6 КБ, во втором - 36 КБ.
Но второй файл не будет иметь никаких дополнительных зависимостей.


4) Пример чуть более сложной программы.

Ассемблируем:
> ml /c hello.asm

Линкуем:
> link hello.obj kernel32.lib user32.lib msvcrt.lib


5) Пример демонстрирует использование заголовочных файлов.
Нет необходимости описывать все библиотечные функции самостоятельно. Для многих функций это уже сделано в проекте masm32, в котором собраны заголовочные и lib- файлы для многих системных библиотек.
